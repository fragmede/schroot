TODO
----

* Add the session UUID to the environment and update documentation.

* chroot access should be restricted to a certain number of
  concurrent users (defaulting to 1).  This could be implemented
  with POSIX semaphores using sem_open()/sem_trywait()/sem_close().

  - Semaphores are not the right structure.  Use simple file locks
    opened with O_CREAT|O_EXCL to control access to the session
    config.  Maintain the user count in the session config.  Locks to
    control block device access are still needed.

  Chroot creation
  ---------------

  - Create a lock on the source blockdev or directory using a semaphore:
    /schroot-block-major-minor or /schroot-directory-major-minor-inode
  - run chroot setup scripts
  - unlock the semaphore

  Session run
  -----------

  Create a lock on the chroot directory using a semaphore.  This is of the form
  /schroot-directory-major-minor-inode, and is used to track the usage
  count of the chroot.  For PVs and devices, use
  /schroot-block-major-minor.

  Chroot teardown
  ---------------

  Re-acquire the chroot lock.


* Add a SbuildChrootXen chroot type for Xen hosts.

* Alternate chroots will require hook scripts to customise them.
  For example, network setup.  Xen in particular will require
  DHCP or static IP configuration and a dynamic hostname in order
  to connect.

* Currently, a session consists of authentication/authorisation, followed
  by session setup, entering a chroot and running commands.  When using a
  non-chroot setups, we also need to consider:

  - initial chroot setup
  - chroot entry/access, possibly over a network
  - running commands, independently, each with their own exit status
    (e.g. sbuild)
  - chroot exit
  - final chroot teardown

  We also need to consider concurrent access to the chroot during this
  time.  Chroot setup/teardown might be expensive, and should only be
  done once per session.  Therefore there must be a mechanism of
  preserving it while running multiple commands.

  Chroot entry and exit might be done at the same time as setup/teardown,
  but it might equally involve e.g. ssh connections, and if running
  several commands, it's important not to tear down the chroot between
  commands.

  If maxusers=2, user 1 could initiate the session, leaving user 2 to
  connect as many times as necessary while user 1 remains connected, but
  idle, and then teardown would take place when the last session exited
  (e.g. using semaphores).

* Allow direct access to the original LV of a snapshot chroot type.
  This should acquire a lock to prevent taking a snapshot during
  modification.  Perhaps we need separate setup and session locks.


SECURITY
--------

Should schroot be converted to C++ for security, or is glib secure
enough?  Please get in touch if you have any thoughts.
